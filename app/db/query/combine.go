package query

import (
	"database/sql"
	"errors"
	"strings"
)

type Combine struct {
	BaseQuery
	db *sql.DB
	tx *sql.Tx
}

// Set Db
func (c *Combine) SetDb(db *sql.DB) {
	c.db = db
}

// Execute SQL
func (c *Combine) Query(sql string, args ...interface{}) (result interface{}, err error) {
	sqlArray := strings.Split(sql, " ")

	switch strings.ToUpper(sqlArray[0]) {
	case "SELECT":
		rows, err := c.db.Query(sql, args...)
		if err != nil {
			return result, err
		}
		return c.parserRows(rows)
	case "INSERT":
		return c.insertRecord(sql, args...)
	case "UPDATE":
		return c.modifyRecord(sql, args...)
	case "DELETE":
		return c.modifyRecord(sql, args...)
	}
	return "", errors.New("this sql is illegal,Please check it")
}

// 查询一条记录
func (c *Combine) QueryRow(sql string, args ...interface{}) *sql.Row {
	if c.tx != nil {
		return c.tx.QueryRow(sql, args...)
	}
	return c.db.QueryRow(sql, args...)
}

// 查询多条记录
func (c *Combine) QueryAll(sql string, args ...interface{}) (*sql.Rows, error) {
	if c.tx != nil {
		return c.tx.Query(sql, args...)
	}
	return c.db.Query(sql, args...)
}

// 插入[更新][删除]n条记录
func (c *Combine) Exec(sql string, args ...interface{}) (sql.Result, error) {
	if c.tx != nil {
		return c.tx.Exec(sql, args...)
	}
	return c.db.Exec(sql, args...)
}

// Begin starts a transaction.
func (c *Combine) Begin() {
	if tx, err := c.db.Begin(); err != nil {
		panic(err.Error())
	} else {
		c.tx = tx
	}
}

//  Commit commits the transaction.
func (c *Combine) Commit() {
	err := c.tx.Commit()
	if err != nil {
		panic(err.Error())
	}
	c.tx = nil
}

//  Rollback aborts the transaction.
func (c *Combine) Rollback() {
	err := c.tx.Rollback()
	if err != nil {
		panic(err.Error())
	}
	c.tx = nil
}

// Insert any rows records & LastInsertId returns the integer generated by the database
func (c *Combine) insertRecord(sql string, args ...interface{}) (id int64, err error) {
	if c.tx != nil {
		result, err := c.tx.Exec(sql, args...)

		if err != nil {
			return id, err
		}
		return result.LastInsertId()
	} else {
		result, err := c.db.Exec(sql, args...)

		if err != nil {
			return id, err
		}
		return result.LastInsertId()
	}
}

// Update or Delete any rows records & RowsAffected returns the number of rows affected by an update, insert, or delete.
// Not every database or database driver may support this.
func (c *Combine) modifyRecord(sql string, args ...interface{}) (rowsNum int64, err error) {
	if c.tx != nil {
		result, err := c.tx.Exec(sql, args...)
		if err != nil {
			return rowsNum, err
		}
		return result.RowsAffected()
	} else {
		result, err := c.db.Exec(sql, args...)
		if err != nil {
			return rowsNum, err
		}
		return result.RowsAffected()
	}
}

// 设置Db
func (c *Combine) parserRows(rows *sql.Rows) (list []map[string]interface{}, err error) {
	defer rows.Close() // 关闭连接

	// 返回字段的数组
	columns, err := rows.Columns()
	if err != nil {
		return list, err
	}

	// 迭代后者的 Next() 方法，然后使用 Scan() 方法给对应类型变量赋值，以便取出结果，最后再把结果集关闭（释放连接）
	length := len(columns) // 字段数组长度
	for rows.Next() {
		// 接收参数
		args := make([]interface{}, length)
		for k := range args {
			args[k] = &args[k]
		}

		// 数据行接收
		_ = rows.Scan(args...)
		row := make(map[string]interface{})
		for i := 0; i < length; i++ {
			key := columns[i]
			var value string
			if args[i] == nil {
				value = ""
			} else {
				value = string(args[i].([]byte))
			}
			row[key] = value
		}

		// 赋值
		list = append(list, row)
	}
	return list, nil
}
